//! Module for common human interface devices (HIDs).
//!
//! "Device" is a very generic term that could even qualify consoles, mobile phones and
//! computers, but this module really is more about "HID"s, a more specific term that
//! qualifies mice, keyboards, gamepads and so on
//! (see [Wikipedia's definition](https://en.wikipedia.org/wiki/Human_interface_device)).
//!
//!
//! # F.A.Q
//!
//! ## What's in a `DeviceID` ?
//!
//! Essentially, two parts :
//! - An actual, backend-specific ID; this ID is only valid as long as the device is "alive".
//! - A unique token, generated by this crate as the device is plugged for the first time.
//!
//! In order to understand the point of the token, picture the following:
//!
//! 1. User plugs some gamepad; the backend reports an ID equal to, say, 13.
//! 2. Your application keeps a copy of the ID, assuming it always refers to that gamepad.
//! 3. User unplugs the gamepad, and then plugs some mouse.
//!    The backend decides that the ID `13` is free for reuse since the gamepad was unplugged,
//!    and decides to use it for the mouse now.
//! 4. What your application thinks is a gamepad is now a mouse. Assumptions are broken and bad
//!    things happen.
//!
//! The token gives this crate the ability to detect when your aplication is
//! using a stale ID. What your app should do in this case is just drop the ID because
//! it obviously breaks assumptions.  
//! Also, either way, your app should handle `DeviceDisconnected` events and drop
//! the associated IDs.
//!
//!
//! ## Why aren't there strongly-typed ID types for each device kind?
//!
//! This was my first approach and I ended up moving away from it, for these reasons:
//!
//! - This was a actually more of a pain to deal with than it's worth.
//!   It makes for too many type aliases to remember and cope with all the time.
//! - It's a chore to deal with as more device kinds are added. In other words, it does not scale well.
//! - Actually, we can't just classify a device as being of one kind AND NOT any other.
//!   In fact, the proper way to classify devices is not the first one that comes to mind!
//!   See next question.
//!
//!
//! ## Why aren't there separate, well-defined device kinds ? There's no way my mouse is also a keyboard!
//!
//! Famous last words! :) Here are the reasons there is no `enum DeviceKind { ... }` :
//!
//! Often, backends do not provide such exact information; What we can ask them is not "Are you
//! a ...?" but "Do you look like a ...?", "Do you behave like a ...?".
//! Essentially, they allow device kinds to be expressed as
//! a set of flags rather than a single discriminant value.  
//! Converting a set of flags into a single value is loss of information, plain and
//! simple; which we definitely do not want.
//!
//! There's also the case of pen tablets; they are treated as mice by the backend (in fact, they
//! are litterally replacements for mice; that's the whole point), AND some of them are also
//! touch surfaces. However there are definitely mice that are not tablets, and touch surfaces that
//! are not tablets either.
//!
//! It gets worse on Linux:
//! `udev` doesn't prevent a controller device from reporting itself as both a joystick and a gamepad, or both a steering wheel and a
//! gamepad, etc. You can't just say "this is only a gamepad" or "this is only a steering wheel",
//! even though **in practice**, **in the average case**, you might.
//!
//! Also on Linux, there is `uinput` which allows users to create their own virtual devices however
//! they like. The consequences? **A device might be a mouse, keyboard, tablet, and gamepad all
//! at the same time**, and this would be **wanted** by the end user.
//!
//! You are always free to make your own `enum` for distinct device types if you find it convenient
//! in your application, but at least the loss of information is under your control, not enforced
//! by this crate.
//!
//!
//! ## If there's a catch-all `DeviceInfo`, why isn't there a `DeviceState` as well?
//!
//! Ideally, that's the way we would like it to be, but backends disagree.  
//!
//! Some allow querying the whole state of the device in a single call (e.g Windows' XInput),
//! at which point it is a waste to call that API once for each button or axis. This also
//! applies to keyboards on most platforms; they offer ways to efficiently retrieve the state
//! of all keys at once.  
//! Most others only allow querying one button or axis at a time, at which point it is a waste
//! to try to collect everything if you're just interested in a handful of items.
//!
//! In fact, trying to cram everything into a `DeviceState` would not _reflect the reality_ of
//! backends. Making `DeviceInfo` as big and generic as it is is a good decision, because it can
//! deal with all cases and does not lose information, but this is not true of device _state_.  
//! If you're interested in a tablet's state, there's no point in retrieving some associated "mouse state"
//! as well, because all the info that you need is there already.
//!
//! So this crate provides such state query facilities on a careful case-by-case basis.  
//! Notice, for instance, the `controller_state()`, `controller_button_state()` and
//! `controller_axis_state()` methods. The first does query the whole state into an opaque
//! `ControllerState` struct, and the last two query axes or buttons individually.  
//! Which of these is more efficient is implementation-dependant, but you get to choose,
//! especially when you _know_ your platform and what you want to do.
//!
//! ## What's a master HID ?
//!
//! This concept exists on X11 with the XInput extension.
//!
//! Basically you may have multiple devices that behave like a mouse (say, the touchpad on a
//! laptop, an USB mouse and a pen tablet), all connected and working at the same time. However, they all
//! control a common, single _mouse pointer_, the one you see on the screen.
//!
//! XInput defines that mouse pointer as a _master_ device; your actual devices are defined as
//! _slave_ devices that have (or not) a say in how the _master_ device behaves.
//!
//! This model allows having multiple mouse pointers on a user session instead of only one (this is referred to as MPX
//! (Multi-Pointer eXtension)), and the
//! physical devices may be attached to one or another of them; You may therefore have one cursor controlled
//! by a mouse, and one cursor controlled by a pen tablet.
//!
//! The same applies for keyboards.
//!
//!
//! ## What's a parent HID ?
//!
//! This concept exists at least on Linux. This corresponds to whatever the backend reports as
//! being a "parent" device.
//! For instance, a single pen tablet may be reported as multiple "child" devices: A touch surface,
//! a mouse, and button pad. The parent of any of these should be the pen tablet itself, 
//! hopefully reported as a single, normal device stripped of its capabilities (because they're in the
//! children) but this is unclear; it depends too much on obscure platform-specific and
//! driver-specific behaviour.
//!
//! Anyway this crate exposes this features because it might be useful.
//!
//!
//! ## Why expose so much information about devices?
//!
//! My mindset is "if it exists and is exposed, it's going to be useful for someone".
//!
//! It's true that this _does_ eat up some memory, but in all honesty, this is nothing compared
//! to what a decent application allocates by itself. Even if you don't use this information,
//! it already lives in the operating system kernel's memory _anyway_. We're only doing what a
//! normal library does by prefetching everything we need into a convenient representation.
//!
//! Why would anyone care about the driver's name? Well, buggy drivers do (and will) exist, and
//! users only care as long as the application they want to use "works". Working around
//! buggy/quirky drivers is definitely a thing, and it's hard to do without any hint.
//!
//! Knowing about the `Bus` may be useful if your application wants to display a nice icon
//! next to some dropdown list of connected devices.
//!
//! The same applies to anything backends are able to report.
//!
//!
//! ## Why prefetch so much information eagerly?
//!
//! Mostly convenience for the implementation. Other reasons include :
//! - Predictable memory allocation patterns. If the information was returned "lazily",
//!   there would be allocations multiple times instead of once.
//! - Separation of concerns.  
//!   There are two kinds of queries: those that query real-time
//!   state (Is the device plugged? What's the state of this button? etc) and those
//!   that query some kind of static database (typically, the device's information, including its
//!   capabilities).
//!   Said database is _supposed_ to outlive the device (which is the case for some backends).
//!   By prefetching everything ASAP and keeping it warm for later, this crate gives you
//!   the opportunity to keep using a device's information even after it is unplugged.
//!
//!
//! ## Why aren't `Info` structs plain-old-data structs with public fields?
//!
//! This allows introducing new features in a way that doesn't break existing code.  
//! For instance, introducing a new public field breaks code that destructures such `struct`s
//! in an exhaustive way. Introducing a new method does not.
//!
//! This also allows this crate to choose whatever internal representation makes most sense
//! for each platform; A nice consequence is also that less memory is wasted.
//!
//!
//! ## Why do mouse position values use `f64`?
//!
//! Some backends offer subpixel precision, in which case values are more precise than simple
//! integers; you can be "somewhere between" a few pixels.
//!
//! `f64` is likely overkill compared to `f32`, but y'know, in 2030 we might have Supra-Ultra-HD
//! screens.
//!
//!
//! ## Why are axis values `f64`?
//! 
//! Because this is the widest standard number type, so it is an excellent common denominator across
//! implementations. Because of its width, conversion from 16-bit and 32-bit integers (which is what backends often report)
//! is lossless.
//!
//! Beware though, this never means that values are "normalized" (whatever that means).
//! A value is only meaningful in the context of an `AxisInfo` and the process of "normalizing" it
//! is up to you.
//!
//! Using a newtype would be pointless here, because it would have to provide `to_f64()` and
//! `to_i32()` methods, but `f64`-to-`i32` conversion is lossy.
//!
//! Let's just use `f64` and call it a day; you are free to cast it to whatever type you like.
//!
//!
//! ## Why aren't axis values normalized to spare me some time?
//!
//! Because your definition of "normalized" doesn't always apply;
//! here are examples of possible axis ranges:
//!
//! - [-100, 100]: OK. This could be normalized to [-1; 1].
//! - [0, 100]: OK. This could be normalized to [0, 1].
//! - [-32768, 32767]: (this is [i16::MIN, i16::MAX]) OK. This could be normalized to [-1; 1].
//!   But notice already that the range's center does not lie exactly at 0.
//! - [100, -100]: Ermmm, what? Indeed, this is never supposed to happen. But the definitions
//!   of "minimum" and "maximum" are left quite vague by some backends.
//!   I bet some drivers could report this when, for instance, an axis is reversed or something.  
//!   **TL:DR;** Should not happen, but better be careful!
//! - [-10, 30]: So what do we do now? We could normalize [-10, 0] to [-1, 0], then [0, 30] to [0, 1],
//!   but then **our** zero does not represent the "center" of the range anymore.  
//!   We could also "shift" the range to [-20, 20] and normalize this, but we've basically changed
//!   the value's meaning!
//!   We could also pretend this is a [-30, 30] range (taking the absolute maximum value) and
//!   normalize the value using this range. This looks good, but I would not expect
//!   everybody to agree on this.
//!
//! Normally, you should always get any or all of the first three, "good" cases.  
//! The reason this crate does not normalize values for you really is because of the last, "bad"
//! cases, that should never happen, but may, for some reason.
//!
//! This can be a complicated matter and you know best how you want to deal with it.  
//! I would advise writing a utility function that performs the calculation that _you_ think
//! make sense, as long as it doesn't `assert`, so your application doesn't panic just because
//! of unexpected axis ranges.

use uuid::Uuid as Guid;
use std::collections::HashMap;
use std::path::Path;
use std::ops::{Range, Not};
use context::Context;
use os::{OsDeviceID, OsDeviceInfo, OsAxisInfo};
use event::EventInstant;

pub mod error;
pub use self::error::*;
pub mod mouse;
pub use self::mouse::*;
pub mod keyboard;
pub use self::keyboard::*;
pub mod touch;
pub use self::touch::*;
pub mod tablet;
pub use self::tablet::*;
pub mod controller;
pub use self::controller::*;

/// A button or key state, i.e "up" or "down".
///
/// This type exists only because a `bool` is not explicit enough;
/// `some_key.is_down()` and `some_key.is_up()` is more explicit
/// and less error-prone.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ButtonState {
    /// The button or key is being held down.
    Down,
    /// The button or key is up.
    Up,
}
/// A key is mostly the same thing as a button.
pub type KeyState = ButtonState;

impl ButtonState {
    /// Is the button or key being held down?
    pub fn is_down(&self) -> bool {
        self == &ButtonState::Down
    }
    /// Is the button or key up?
    pub fn is_up(&self) -> bool {
        self == &ButtonState::Up
    }
    /// Flips this button state.
    pub fn flip(&mut self) { 
        *self = !*self;
    }
    /// This button state, flipped.
    pub fn flipped(&self) -> Self { 
        !*self
    }
}

/// The `!` operator flips a `ButtonState`.
impl Not for ButtonState {
    type Output = Self;
    fn not(self) -> Self {
        match self {
            ButtonState::Down => ButtonState::Up,
            ButtonState::Up => ButtonState::Down,
        }
    }
}

/// Information about an absolute unidimensional axis.
///
/// The content of this `struct` is mostly taken from Linux's `input_absinfo` `struct`.
///
/// Multidirectional axii will want to expose one `AxisInfo` per dimension.
#[derive(Debug, Clone, PartialEq)]
pub struct AxisInfo(pub(crate) OsAxisInfo);

impl AxisInfo {
    /// The minimum and maximum values this axis can take.
    pub fn range(&self) -> Range<f64> { self.0.range() }
    /// A range within which the driver claims to ignore events from this axis (also referred to as `flat`).
    pub fn driver_dead_zone(&self) -> Option<Range<f64>> { self.0.driver_dead_zone() }
    /// A range within which input should be ignored by your application, if exposed by the backend.
    ///
    /// Not all backends expose this, but if they do, you should not treat the value as truthful.  
    /// Take it only as a hint, but still allow it to be configurable in your app.
    ///
    /// See [Dead zone (MSDN, _Getting started with XInput_)](https://msdn.microsoft.com/en-us/library/windows/desktop/ee417001(v=vs.85).aspx#dead_zone).
    pub fn advised_dead_zone(&self) -> Option<Range<f64>> { self.0.driver_dead_zone() }
    /// Resolution, in units per millimeter for positional axes, or units per radian for rotational axes.
    ///
    /// This is mostly Linux-specific and probably not useful.
    pub fn resolution_hint(&self) -> Option<f64> { self.0.resolution_hint() }
    /// Linux-specific, fuzz value that is used to filter noise from the event stream.
    /// 
    /// The input system in Linux will drop events generated by the device driver
    /// if the difference from the last value is lower than the fuzz value.
    ///
    /// (See this StackOverflow answer)[https://stackoverflow.com/a/17041513/7972165].
    pub fn driver_noise_filter(&self) -> Option<f64> { self.0.driver_noise_filter() }
}

/// Information about a HID (often fetched once when the device is detected).
///
/// A lot of these fields are optional because not all backend (and not all drivers)
/// provide the same amount of information. In addition, some devices are somewhat "virtual"
/// (for instance, the "core" pointer and keyboard in X11) and provide very little
/// information about them (only a name, for instance).
///
/// So, this is a bit cumbersome to work with, but this is indeed the common denominator
/// across platforms, backends, drivers and devices.
///
/// There's normally no point in having so much information about a device, but this might be
/// useful for several purposes:
///
/// - Displaying the friendly name for this device to the user;
/// - Knowing if this is a master device; If it is, the `master` member is `None`.
/// - Identifying a very specific device model, via the USB product info;
///   This is how you could detect that a controller is in fact a "XBox One S" gamepad, for instance.
/// - Identifying the driver, which could be useful for bug reports and patching your application
///   accordingly if the driver is known to be buggy;
#[derive(Debug, Clone, PartialEq)]
pub struct DeviceInfo(pub(crate) OsDeviceInfo);

/// TODO: Player Number for Xbox controllers!
impl DeviceInfo {
    /// The master HID, if any.
    pub fn master(&self) -> Option<DeviceID> { self.0.master() }
    /// The parent HID, if any.
    pub fn parent(&self) -> Option<DeviceID> { self.0.parent() }
    /// On Unices, a device is also a file, e.g `/dev/input/event13`.
    pub fn device_node(&self) -> Option<&Path> { self.0.device_node() }
    /// General-purpose, user-friendly name for this device.
    pub fn name(&self) -> Option<&str> { self.0.name() }
    /// Generic serial string for this device. This is whatever the backend or driver advertises as
    /// a "serial".
    pub fn serial(&self) -> Option<&str> { self.0.serial() }
    /// USB product info, if any.
    pub fn usb_ids(&self) -> Option<UsbIDs> { self.0.usb_ids() }
    /// Friendly name for the USB vendor ID, if exposed by the backend.
    /// Note that it may change across devices, on a same platform,
    /// even though the vendor ID is the same.
    ///
    /// There is no `product_name` field because it is, in fact, the device's name,
    /// which is already reported.
    pub fn vendor_name(&self) -> Option<&str> { self.0.vendor_name() }
    /// GUID for this device, if any. This is normally only relevant for Windows.
    pub fn guid(&self) -> Option<Guid> { self.0.guid() }
    /// The time at which this device was first plugged.
    pub fn plug_instant(&self) -> Option<EventInstant> { self.0.plug_instant() }
    /// The bus by which this device is connected.
    pub fn bus(&self) -> Option<Bus> { self.0.bus() }
    /// The name of the driver, as advertised by the backend.
    pub fn driver_name(&self) -> Option<&str> { self.0.driver_name() }
    /// The driver version in its platform-specific representation.
    /// This is a string because there's no uniform representation for driver versions across
    /// platforms. If you really care, this still allows you to attempt to parse it yourself.
    pub fn driver_version(&self) -> Option<&str> { self.0.driver_version() }
    /// Does this device denote an actual, physical one?
    ///
    /// This is a pretty tough question to answer and the meaning, albeit vague, is not
    /// related to the notion of master devices.
    ///
    /// For instance, Linux has `uinput` which allows users to create virtual devices.
    /// These are NOT master devices, but they still don't have a physical form.
    ///
    /// This member is mostly a hint for you, the application writer, for whatever purpose
    /// feels relevant to you.
    pub fn is_physical(&self) -> Option<bool> { self.0.is_physical() }
    /// If this device is a controller, then controller-specific info is stored here.
    pub fn controller(&self) -> Option<&ControllerInfo> { self.0.controller() }
    /// If this device is a mouse, then mouse-specific info is stored here.
    pub fn mouse(&self) -> Option<&MouseInfo> { self.0.mouse() }
    /// If this device is a keyboard, then keyboard-specific info is stored here.
    pub fn keyboard(&self) -> Option<&KeyboardInfo> { self.0.keyboard() }
    /// If this device is a touch screen/pad, then specific info is stored here.
    pub fn touch(&self) -> Option<&TouchInfo> { self.0.touch() }
    /// If this device is a tablet, then tablet-specific info is stored here.
    pub fn tablet(&self) -> Option<&TabletInfo> { self.0.tablet() }
}

#[allow(missing_docs)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct UsbIDs {
    /// The USB vendor ID, usually display in hexadecimal.
    pub vendor_id: u16,
    /// The USB product ID, usually display in hexadecimal.
    pub product_id: u16,
}

/// Mostly taken from the `BUS_*` constants in Linux's `input.h`.
#[allow(missing_docs)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Bus {
    Pci,
    Usb,
    Bluetooth,
    Virtual,
}

/// An ID for a HID.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DeviceID(pub(crate) OsDeviceID);

impl Context {
    /// Lists all currently connected devices, in no particular order.
    /// 
    /// **N.B**: The returned list **may, or may not,** be "in sync" with the event queue.  
    /// However, the result _always_ includes devices that were already present _before_ the
    /// event queue was set up (which is the whole point).
    ///
    /// This all means that some devices could have been added or removed
    /// without you having handled the associated `DeviceConnected`/`DeviceDisconnected`
    /// events _yet_.  
    /// **This is important if you keep an internal list of devices.**  
    /// When you handle `DeviceConnected`, do not assume the device **was not** present before.  
    /// When you handle `DeviceDisconnected`, do not assume the device **was** present before.
    ///
    /// This method may be expensive, so you are advised to call this only once
    /// when your application starts, and collect the output into your own data structure;
    /// then, never call this again and only update (carefully) your own data structure via events.
    ///
    /// `DeviceInfo`s are provided in the process to avoid race conditions.  
    /// If we can't get the `DeviceInfo` for a `DeviceID`, then we can't do anything with it
    /// and there's no point in listing it (it was probably disconnected; bad timing!).  
    /// If we _can_ get the `DeviceInfo` (99.9% of cases), then we want to do this only once, because it may
    /// be expensive, and then get rid of it by handing it over to you.
    pub fn devices(&self) -> Result<HashMap<DeviceID, DeviceInfo>> {
        self.0.devices()
    }
    /// Checks if the given device is still connected.  
    ///
    /// This may have an additional, harmless meaning in the future for devices
    /// that do need to be ping-ed regurlarly by clients.
    ///
    /// This is normally not useful and prone to race conditions; If the device is connected
    /// right now, that doesn't mean it will still be connected within the next few milliseconds.
    pub fn ping_device(&self, id: DeviceID) -> Result<()> {
        self.0.ping_device(id)
    }
}
