//! Module for common human interface devices (HID).
//!
//! This module is named "HID" because it is a short and nice term for
//! human input/output devices, which excludes e.g hard drives, usb disks, GPUs, etc.  
//!
//! "Device" is a very generic term that could even qualify consoles, mobile phones and
//! computers, but "HID" is more specific and includes mice, keyboards, gamepads and so on.
//!
//! For a rationale, see [Wikipedia's definition](https://en.wikipedia.org/wiki/Human_interface_device).
//!
//! A master HID is the "physical" counterpart to what is called an HID in this module.  
//! To illustrate, a graphics tablet may be reported as two devices: a `Touch` and a `Tablet`,
//! but both really are features of a single physical device; this physical device is the master
//! HID.

use std::ops::{Range, Not};
use context::Context;
use event::Timestamp;
use os::{OsMasterHidId, OsDeviceId};

pub mod mouse;
pub use self::mouse::*;
pub mod keyboard;
pub use self::keyboard::*;
pub mod touch;
pub use self::touch::*;
pub mod tablet;
pub use self::tablet::*;
pub mod controller;
pub use self::controller::*;

/// Error returned by operations from this module and submodules.
#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub enum Error {
    /// The device was disconnected at the specific timestamp.
    DeviceDisconnected(Timestamp),
    /// Another error occured (in the meantime, it is unknown whether or not the device is still connected).
    Other(super::error::Error),
}

/// Convenience alias to `Result<T, Error>`.
pub type Result<T> = ::std::result::Result<T, Error>;

#[allow(dead_code)]
pub(crate) fn disconnected<T>(timestamp: Timestamp) -> Result<T> {
    Err(Error::DeviceDisconnected(timestamp))
}

/// A button or key state, i.e "up" or "down".
///
/// This type exists only because a `bool` is not explicit enough.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ButtonState {
    /// The button or key is being held down.
    Down,
    /// The button or key is up.
    Up,
}
/// A key is mostly the same thing as a button.
pub type KeyState = ButtonState;

impl ButtonState {
    /// Is the button or key being held down?
    pub fn is_down(&self) -> bool {
        self == &ButtonState::Down
    }
    /// Is the button or key up?
    pub fn is_up(&self) -> bool {
        self == &ButtonState::Up
    }
    /// Flips this button state.
    pub fn flip(&mut self) { 
        *self = !*self;
    }
}

/// The `!` operator flips a `ButtonState`.
impl Not for ButtonState {
    type Output = Self;
    fn not(self) -> Self {
        match self {
            ButtonState::Down => ButtonState::Up,
            ButtonState::Up => ButtonState::Down,
        }
    }
}

/// Information about a unidimensional axis.
///
/// The content of this `struct` is mostly taken from Linux's `input_absinfo` `struct`.
///
/// Multidirectional axii will want to expose one `AxisInfo` per dimension.
#[derive(Debug, Clone, PartialEq)]
pub struct AxisInfo {
    /// The minimum and maximum values this axis can take.
    pub range: Range<f64>,
    /// A range within which input should probably be ignored.
    ///
    /// Not all backends expose this, but if they do, you should not treat the value as truthful,
    /// because even drivers may get it wrong.
    ///
    /// Therefore, you should take it only as a hint, but still allow it to be configurable in your app.
    pub dead_zone: Option<Range<f64>>,
    /// Resolution, in units per millimeter, or units per radian.
    ///
    /// This is mostly Linux-specific and probably not useful.
    pub resolution: f64,
    /// Linux-specific, fuzz value that is used to filter noise from the event stream.
    /// 
    /// The input system in Linux will drop events generated by the device driver
    /// if the difference from the last value is lower than the fuzz value.
    ///
    /// (See this StackOverflow answer)[https://stackoverflow.com/a/17041513/7972165].
    pub fuzz: f64,
}

/// Information about a HID (often fetched once when the device is detected).
#[derive(Debug, Clone, PartialEq)]
pub struct HidInfo {
    /// The master HID, if any.
    pub master: Option<MasterHidId>,
    /// General-purpose, user-friendly name for this device.
    pub name: String,
    // pub serial: Option<String>,
    /// USB product info, if any.
    pub usb_product_info: Option<HidUsbProductInfo>,
    //pub guid: Option<Guid>,
    /// The time at which this device was first plugged.
    pub plug_timestamp: Timestamp,
    /// The bus by which this device is connected.
    pub bus: Bus,
    //pub driver_version: Option<Semver>,
}

#[allow(missing_docs)]
#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub struct HidUsbProductInfo {
    pub vendor_id: u16,
    pub product_id: u16, // NOTE: ID_MODEL_ID on udev
    pub vendor_name: String,
    pub product_name: String, // NOTE: ID_MODEL on udev
}

/// Mostly taken from the `BUS_*` constants in Linux's `input.h`.
#[allow(missing_docs)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Bus {
    Pci,
    Usb,
    Bluetooth,
    Virtual,
}

pub trait AnyDeviceId: OsDeviceId {}
impl<T: OsDeviceId> AnyDeviceId for T {}

/// An ID for a master HID.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MasterHidId(pub(crate) OsMasterHidId);

impl Context {
    /// Get the `HidInfo` for the given device ID.
    fn hid_info<Id: AnyDeviceId>(&self, id: Id) -> Result<HidInfo> {
        self.0.hid_info(id)
    }
    /// Checks if the given device is still connected.
    fn ping_hid<Id: AnyDeviceId>(&self, id: Id) -> Result<()> {
        self.0.ping_hid(id)
    }
}
