# Design decisions

Le plus bas niveau possible quand même ! ex.
FpsLimiter => NON
Axis2D, Axis3D... NON


Les borrows et les lifetimes sont chiants.
Utiliser des Rc, parce qu'on peut.
En plus les lifetimes des objets dépendent de la plateforme.
Un Event devrait être self-contained.

Il n'y a pas de solution parfaite
Les solutions existantes sont déjà des hacks. Pas thread-safe,
qui stockent des infos redondantes, etc.

On veut le contrôle
Pouvoir opt-in pour accéder aux handles natives.

Il ne DEVRAIT y avoir qu'un seul contexte.
(Sous X11 c'est peut-être safe d'en avoir plusieurs)

Le contexte ne devrait pas tout posséder.
Il devrait donner l'ownership sur des Windows, Hid, etc.
Ceux-ci ont un Rc<Context> parce que :
- Ils peuvent devoir vivre aussi longtemps que le contexte;
- Ils peuevtn avoir besoin de passer par le contexte pour faire des opérations;
- Evite les lifetimes et borrows chiants (vs. une référence immutable)

Personne ne garde d'infos en cache !!!
Quand on demande la position du cursor, ou la taille de la fenêtre, ça DOIT
la demander à l'OS. L'utilisateur peut avoir son propre cache s'il le souhaite.

Les events devraient être du POD, sans lifetimes.

Pour identifier une fenêtre, il faudrait un wrapper autour de l'identifiant natif.
ex: SomeWindowEvent { handle: OsWindowHandle, data: ... }
ex: SomeHidEvent { handle: OsHidHandle, data: ... }
C'est ensuite à l'utilisateur de faire un truc en fonction. Deux choix:
- La window appartient à l'utilisateur:
  Il fait un lookup dans sa propre structure de données;
  my_windows.find(|w| w.os_handle() == event.handle);
- La window est étrangère:
  Il peut appeler Window::from_os_handle(handle); et interagir avec.

Pas de constantes genre GL_4_5 !!!
Raison: Ce n'est pas future proof, et ça n'apporte pas grand chose face à e.g GL(4,5).

# Processus
- Repartir de zéro et tester absolument chaque feature quand elle sort;
- Bien séparer en modules pour préparer l'avenir.
- On ne ship pas tant qu'il y a des unimplemented!{}

# Features
- error: ErrorKind, Error, Result
- context:
  v new() -> Result<Self>
  v with_x11_display_name(&CStr) -> Result<Self>
  v with_xlib_display_ptr(ptr) -> Result<Self>
  v xlib_display() -> *mut x::Display
  -
  - create_window(&WindowSettings)
  -
  - choose_gl_pixel_format(&GLPixelFormatSettings) -> Result<GLPixelFormat>
  - create_gl_context(&GLPixelFormat, &GLContextSettings) -> Result<GLContext>
  - create_software_gl_context(&GLPixelFormat, &GLContextSettings) -> Result<GLContext>
  - create_software_gl_context(&GLPixelFormat, &GLContextSettings, Path) -> Result<GLContext>
  -
  - poll_events() -> events::PollIter
  - wait_events(timeout: Duration) -> events::WaitIter
  -
  - udev() -> *mut udev::udev
  - udev_monitor() -> *mut udev::udev_monitor
  -
  - best_cursor_size(Extent2<u32>) -> Extent2<u32>
  - create_rgba_cursor(&RgbCursorData) -> Result<Cursor>
  - create_rgba_cursor_anim(&RgbCursorAnim) -> Result<Cursor>
  - create_rgb_cursor(&RgbCursorData) -> Result<Cursor>
  - create_rgb_cursor_anim(&RgbCursorAnim) -> Result<Cursor>
  - create_system_cursor(SystemCursor) -> Result<Cursor>
- window:
  - show()
  - hide()
  - set_title()
  - set_icon()
  - clear_icon()
  - set_style()
  - recenter()
  - set_opacity()
  - maximize() // Take as much space as possible
  - unmaximize()
  - toggle_maximize()
  - minimize() // Minimize to task bar
  - unminimize()
  - toggle_minimize()
  - raise()
  - enter_fullscreen()
  - leave_fullscreen()
  - toggle_fullscreen()
  - set_min_size()
  - set_max_size()
  - canvas_size()
  - size()
  - set_size()
  - position()
  - set_position()
  - position_and_size()
  - set_position_and_size()
  - show_cursor()
  - hide_cursor()
  - toggle_cursor_visibility()
  - set_cursor()
  - set_cursor_position()
  - cursor_position()
  - demand_attention()
  -
  - make_gl_context_current()
  - present_gl()
  - set_gl_swap_interval()
- gl:
  - GLContext
    unsafe get_proc_address(*const c_char) -> Option<OsGLProc>
- hid:
  - Mouse
  - Keyboard
  - Tablet
  - Touch
  - Controller
- event: juste un gros enum
  Reply TRUE to WM_QUERYENDSESSION, in which case we then get WM_ENDSESSION.
  ShutdownBlockReasonDestroy
  Reply FALSE to WM_QUERYENDSESSION.
  ShutdownBlockReasonCreate
- battery: BatteryState::current()
